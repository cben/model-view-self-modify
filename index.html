<style>
  .cm-editor {
    border: inset grey 1px;
    height: 85vh;
  }
</style>

<script type="importmap">
  {
    "imports": {
      "@codemirror/basic-setup": "https://unpkg.com/@codemirror/basic-setup/dist/index.js",
      "@codemirror/autocomplete": "https://unpkg.com/@codemirror/autocomplete/dist/index.js",
      "@codemirror/commands": "https://unpkg.com/@codemirror/commands/dist/index.js",
      "@codemirror/language": "https://unpkg.com/@codemirror/language/dist/index.js",
      "@codemirror/lang-javascript": "https://unpkg.com/@codemirror/lang-javascript/dist/index.js",
      "@codemirror/lint": "https://unpkg.com/@codemirror/lint/dist/index.js",
      "@codemirror/search": "https://unpkg.com/@codemirror/search/dist/index.js",
      "@codemirror/state": "https://unpkg.com/@codemirror/state/dist/index.js",
      "@codemirror/view": "https://unpkg.com/@codemirror/view/dist/index.js",
      "@lezer/common": "https://unpkg.com/@lezer/common/dist/index.js",
      "@lezer/highlight": "https://unpkg.com/@lezer/highlight/dist/index.js",
      "@lezer/javascript": "https://unpkg.com/@lezer/javascript/dist/index.es.js",
      "@lezer/lr": "https://unpkg.com/@lezer/lr/dist/index.js",
      "style-mod": "https://unpkg.com/style-mod/src/style-mod.js",
      "w3c-keyname": "https://unpkg.com/w3c-keyname/index.js",
      "crelt": "https://unpkg.com/crelt/index.js"
    }
  }
</script>

<script type="module">
  // htm gives us JSX-like notation in standard JS tagged template literals.
  import {
    html, // bound to preact's createElement() constructor.
    render, Component, useEffect, useState, useRef
  } from 'https://unpkg.com/htm/preact/standalone.module.js'

  import { EditorState, basicSetup } from '@codemirror/basic-setup';
  import { EditorView, keymap } from '@codemirror/view';
  import { defaultKeymap, indentWithTab } from '@codemirror/commands';
  import { javascript } from '@codemirror/lang-javascript';

  // -- Imports to be used by user code --

  window.html = html
  // TODO: https://stackoverflow.com/questions/47978809/how-to-dynamically-execute-eval-javascript-code-that-contains-an-es6-module-re
  import _ from 'https://unpkg.com/lodash-es'
  window._ = _
  // import range from 'https://unpkg.com/lodash-es/range.js'
  // window.range = range

  // --- https://stackoverflow.com/a/76452154/239657 ---

  // Firefox reports 1-based `lineNumber`, but also inserts `function anonymous(arg1, arg2` as line 1,
  // and `) {` as line 2 (see .toString() on successfully parsed functions). Measure instead of guessing!
  let functionLineOffset = 0
  try {
    Function('!@#$')
  } catch (err) {
    functionLineOffset = err.lineNumber
  }

  // Uses `Function` constructor rules: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/Function
  //  - `code` should contain a `return` statement if you want a result.
  //  - assignments without `var`/`let`/`const` do write to global namespace.
  var betterEvalFunction = code => {
    let parsedFunc
    try {
      // sourceURL pragma makes stack traces more readable.
      parsedFunc = new Function(code + '\n//# sourceURL=evaluated-code')
    } catch (err) {
      if (err instanceof SyntaxError) {
        // Goal: find & show responsible line directly in the message
        const { name, message, lineNumber, columnNumber } = err
        var lines = code.split('\n')

        // Firefox, non-standard
        if (lineNumber !== undefined) {
          const line = lineNumber - functionLineOffset
          throw SyntaxError(
            `${message} (at ${line + 1}:${columnNumber}):\n` +
            `${lines[line] || ''}\n` +
            (columnNumber === undefined ? '' : `${' '.repeat(columnNumber)}^`))
        }

        // Other browsers leave you in the dark :-(
        // ESTIMATE where it happened by slicing lines off the end until message disappears/changes
        // (likely to have unclosed braces etc. — but assuming it reports the first of all errors)
        var lastLine
        for (lastLine = lines.length - 1; lastLine > 0; lastLine--) {
          try {
            new Function(lines.slice(0, lastLine).join('\n')) // only parse, don't call
            // console.log('error disappeared')
            break
          } catch (err2) {
            if (err2.message === err.message && err2 instanceof SyntaxError) {
              continue
            }
            // console.log('error changed to:', err2.message)
            break
          }
        }
        throw SyntaxError(
          `${err.message} (probably around line ${lastLine + 1}):\n` +
          (lines[lastLine] || ''))
      }
      throw err
    }
    return parsedFunc()
  }

  // ---

  var demoCode = 'App = (props) => html`<a href="/">Hello!</a>`'

  var EditEvalRenderLoop = (props) => {
    const [code, setCode] = useState(localStorage.getItem('code') || demoCode)

    const saveCode = (code) => {
      console.log('saveCode')
      localStorage.setItem('code', code)
      setCode(code)
    }

    window.App = () => '`App` not defined.' // TODO: tolerate App being undefined

    let err = undefined
    let evalResult = undefined
    try {
      console.log('Evaluating...')
      evalResult = betterEvalFunction(code)
    } catch (err2) {
      err = err2
    }

    // TODO: use https://github.com/observablehq/inspector for rendering values / components?

    return html`
      <table>
        <td>
          <label>
            <h3>App source:</h3>
              <${Editor} 
                code=${code} setCode=${saveCode}
              />
          </label>
        </td>
        <td>
          <${DisplayResult}
            evalResult=${evalResult}
            err=${err}
            key=${code /*force ErrorBoundary reset after edit (TODO: reduce excessive remounts?)*/}
          />
        </td>
      </table>`
  }

  var Editor = ({ code, setCode, className }) => {
    const onUpdate = (update) => {
      if (update.docChanged) {
        console.log('docChanged', update.state.doc)
        setCode(update.state.doc.toString())
      }
    }

    // https://dev.to/adamcollier/adding-codemirror-6-to-a-react-project-36hl

    const editor = useRef()

    useEffect(() => {
      const startState = EditorState.create({
        doc: code,
        extensions: [
          basicSetup,
          keymap.of([defaultKeymap, indentWithTab]),
          javascript(),
          EditorView.updateListener.of(onUpdate), // TODO callbacks like `setCode` all come from 1st render
        ],
      })

      const view = new EditorView({ state: startState, parent: editor.current })

      // TODO SCOPING KLUDGE TODO
      window.WRITE = (text) => {
        console.log('WRITE', text)
        if (text) {
          const pos = view.state.selection.main.from
          view.dispatch({
            changes: { from: pos, insert: text.toString() },
            selection: { anchor: pos + text.toString().length },
          })
        }
      }

      return () => {
        view.destroy()
      };
    }, [])

    return html`<div className=${className} ref=${editor} />`
  }

  var DisplayResult = ({ evalResult, err }) => {
    if (err) {
      let text
      if (err.stack.includes(err.name)) {
        // Some browsers include `name` & `message` in `stack`
        text = err.stack
      } else {
        text = `${err.name}: ${err.message}\n\n${err.stack}`
      }

      // TODO: line numbers in the stack are all by `functionLineOffset` :-(

      // Omit betterEvalFunction() and its callers from stack.
      // (This also handles SyntaxError not having any useful stack.)
      // Avoid cutting user's frames, even if user code happens to contain same name.
      const cutPos = text.lastIndexOf('betterEvalFunction')
      const userPosToProtect = text.lastIndexOf('evaluated-code')
      if (cutPos >= 0 && cutPos > userPosToProtect) {
        text = text.slice(0, cutPos)
      }

      return html`<div>
        <h3>Exception:</h3>
        <${Error}>${text}<//>
      </div>`
    }

    try {
      evalResult = JSON.stringify(evalResult, null, 2) || evalResult
    } catch (err) {
    }
    try {
      evalResult = evalResult.toString()
    } catch (err) {
    }

    return html`<div>
      <h3>Eval result:</h3>
      ${evalResult}
      <h3>Render App:</h3>
      <${ErrorBoundary}>
        <${App}/>
      <//>
    </div>`
  }

  var Error = ({ children }) =>
    html`<div style=${{ whiteSpace: 'pre-wrap', textAlign: 'left', fontFamily: 'monospace', color: '#a00' }}>
      ${children}
    </div>`;

  class ErrorBoundary extends Component {
    state = {};

    componentDidCatch(error, info) {
      this.setState({ error: error.toString(), componentStack: info?.componentStack });
      console.warn(this.state)
    }

    render() {
      const { error, componentStack } = this.state;
      if (error) {
        return html`<${Error}>
            ${error}
            ${componentStack}
          <//>`;
      }

      return this.props.children;
    }
  }


  render(html`<${EditEvalRenderLoop} />`, document.body)
</script>